#!/usr/bin/env python3

# Vadim Zyamalov <vadim.zyamalov@gmail.com>
# Licensed under the conditions of MIT license

import os
import sys
from xdg.DesktopEntry import DesktopEntry as DE
from subprocess import Popen, PIPE


def dirlist():
    res = []
    try:
        res.append(os.environ['XDG_DATA_HOME'])
    except KeyError:
        res.append('{}/.local/share/applications'.format(os.environ['HOME']))
    try:
        res.extend(os.environ['XDG_DATA_DIRS'].split(':'))
    except KeyError:
        res.extend('/usr/local/share/applications:/usr/share/applications'.split(':'))
    return res


def appdict():
    res = {}
    for path in dirlist():
        try:
            files = os.listdir(path)
        except FileNotFoundError:
            continue
        for curfile in files:
            if not curfile.endswith('.desktop'):
                continue
            curdesktop = DE('{}/{}'.format(path, curfile))
            if not curdesktop.getType() == 'Application':
                continue
            if curdesktop.getNoDisplay() or curdesktop.getHidden():
                continue
            if curdesktop.getName() not in res:
                res[curdesktop.getName()] = {'exec': curdesktop.getExec(),
                                             'term': curdesktop.getTerminal(),
                                             'loc': '{}/{}'.format(path, curfile)}
    return res


def applist(appdict):
    res = []
    for key in appdict.keys():
        res.append(key)
    res.sort()
    return res


def calldmenu(apps):
    dmenu = ['dmenu']
    dmenu.extend(sys.argv[1:])
    appstr = ('\n'.join(apps)).encode('utf8')
    dmenup = Popen(dmenu, stdin=PIPE, stdout=PIPE)
    (res, err) = dmenup.communicate(input=appstr)
    exitcode = dmenup.wait()
    if not exitcode:
        return res.decode('utf8').strip()
    else:
        return ''


def search(choice, appdict):
    possible = choice.split(' ')[0]
    possibleargs = choice[len(possible)+1:]
    for key in appdict:
        if appdict[key]['exec'].find(possible) > -1:
            return key, possibleargs
    return '', ''


def arg_fill(choice, appdict, args=''):
    if choice not in appdict:
        return ''
    res = appdict[choice]['exec']
    res = res.replace('%u', args)
    res = res.replace('%U', args)
    res = res.replace('%f', args)
    res = res.replace('%F', args)
    res = res.replace('%c', '"{}"'.format(choice))
    res = res.replace('%k', appdict[choice]['loc'])
    res = res.replace('%i', '')
    res = res.replace('%%', '%')
    return res.strip()


if __name__ == '__main__':
    try:
        term = os.environ['TERMINAL']
    except KeyError:
        term = 'xterm'
    apps = appdict()
    res = calldmenu(applist(apps))
    args = ''
    if (res != '') and (res not in apps):
        res, args = search(res, apps)
    if res != '':
        fin = arg_fill(res, apps, args)
        if apps[res]['term']:
            Popen('{} -e {}'.format(term, fin), shell=True)
        else:
            Popen(fin, shell=True)
